created: 20161209073642193
draft.of: TypeScript, React, and Redux
draft.title: TypeScript, React, and Redux
modified: 20161209091552141
tags: React Typescript Redux
title: Draft of 'TypeScript, React, and Redux'
type: text/vnd.tiddlywiki

!Action


!![[ redux-actions | https://github.com/acdlite/redux-actions]]

通过`createAction`来生成Action。

!!定义Action

根据[[Typesafe Redux in TypeScript | http://michaellawrie.com/typesafe-redux-in-typescript]]以及[[ TypeScript, React, and Redux | http://www.mattgreer.org/articles/typescript-react-and-redux/ ]]，定义基础的 Action

```typescript
interface Action<T>{
  readonly type:string;
  readonly payload:T;
}

interface ActionCreator<T> {
  readonly type:string
  (payload:T):Action<T>
}

// Bind the action type to the payload creator to describe a new action creator.
// 其中T是payload的类型,这里返回一个对应T的action creator。
const actionCreator = <T>(type: string):ActionCreator<T> =>
  Object.assign((payload:T):any => ({type, payload}), {type})

// 对action的类型保护
export const isType = <T>(action: Action<any>, actionCreator: ActionCreator<T>):
  action is Action<T> => action.type === actionCreator.type


// Example action creator:
export interface ListItem {
  readonly done: boolean
  readonly description: string
}

export const createListItemAction =
  actionCreator<ListItem>('CREATE_LIST_ITEM_ACTION_TYPE')
```
但是根据我司O神的几个观点，还需要再考虑一下更新：

* Type guards are much nicer now. （比如我们可以用 instanceof 来代替 type 的比较）
* const for variable declarations and readonly for fields in interfaces give us something close to Immutable
* We now have tagged union types which allow us to distinguish at runtime what type of action an action is, and know what data is associated with it. We're already doing some of this in Kitten, though our pattern is a little convoluted by optimizations because the interpreter needs to be very fast. Do talk to me when you want to know more about it.


!!Reducer

同样根据 http://michaellawrie.com/typesafe-redux-in-typescript ，可以定义以下reducer：

```typescript
//listItemsReducers.ts

import { ListItem, createListItemAction } from 'listItemsActions'
import Immutable = require('immutable')

type ListItems = Immutable.List<ListItem>

export interface ListItemsState {
  readonly listItems: ListItems 
}

export const listItemsReducers = (state: ListItems = Immutable.List<ListItem>(),
  action: Action<any>): ListItems => {
  
  if (isType(action, createListItemAction)) {
    const listItem = {
      done: action.payload.done,
      description: action.payload.description
    }
    return state.push(listItem)
  }
  
  return state
}
```
!!Store
Store这部分就没什么特别的了

```typescript
// store.ts

import { createStore, combineReducers, Unsubscribe } from 'redux'
import { Action } from 'listItemsActions'
import { listItemsReducers, ListItemsState } from 'listItemsReducers'
import { someOtherReducers, SomeOthersState } from 'someOtherReducers'

const reducer = combineReducers({
  listItems: listItemsReducers,
  someOther: someOtherReducers
})

// 这样做State岂不是意味着每多一个Reducer就多一个State要加进来？有别的办法吗？
export interface State extends ListItemsState, SomeOtherState {}

let store = createStore(reducer)

// 给redux自带的方法上了个类型
export const getState = () => store.getState() as State
export const dispatch = (a:Action<any>) => store.dispatch(a)

// 用来手动绑定State到Component
export const subscribeToState = (callback: () => void) => store.subscribe(callback)
```

!!引入Component

Michael Lawrie 的观点：不用react-redux，我们得保证类型安全，所以还不如像下面这样：

```typescript
//stateConnector.ts

import { getState, State, subscribeToState } from 'state'
import { Component } from 'react'

const hijackComponentWillUnmount = (component: any, callback: () => void) => {
  const componentWillUnmount = component.componentWillUnmount
  component.componentWillUnmount = () => {
    callback()
    if (componentWillUnmount) {
      componentWillUnmount.apply(component);
    }
  }
}
export const stateConnector = <T>(mapState: (s:State) => T, component: Component<any, T>) => {
  let oldState = mapState(getState())
  let wasUnsubscribed = false
  
  const unsubscribe = subscribeToState(() => {
    if (wasUnsubscribed) {
      return;
    }
    const newState = mapState(getState())
    if (/* oldState deeply does not equal newState */) {
      component.setState(newState)
    }

    oldState = newState
  });
  
  hijackComponentWillUnmount(component, () => {
    wasUnsubscribed = true
    unsubscribe()
  }) 
  
  component.state = oldState
}
```


